從這裡開始說說陣列吧。直到目前為止盡是講指標，就當做是換個頭腦來讀一下。

雖然說過很多次了，陣列跟指標是完全不同的!

目前為止看的陣列都是一維的，也就是元素只往同一方向連續排列，如下圖。

          0  1  2  3  4 
        +--+--+--+--+--+
        |  |  |  |  |  |
        +--+--+--+--+--+

但是，在利用圖形或表格之類的資料時，一維陣列是很難用的。所以要用表格形式的資料時，會用到二維陣列。

嚴格來說，C語言不存在二維或多維陣列，但是可以用「陣列的陣列」的陣列宣告方式來實現一樣的事。以下就來介紹。

把二維陣列用圖表示的話，就像下面這樣:

          0  1  2  3  4 
        +--+--+--+--+--+
      0 |  |  |  |  |  |
        +--+--+--+--+--+
      1 |  |  |  |  |  |
        +--+--+--+--+--+
      2 |  |  |  |★|  |
        +--+--+--+--+--+
      3 |  |  |  |  |  |
        +--+--+--+--+--+

看起來就是單純的表格而已。而宣告有點囉唆:

```cpp
data_type 變數名[縱向元素數][橫向元素數]
```

如果要宣告像剛剛的二維陣列，就像下面這樣寫:

```cpp
int tuple[4][5]
```
圖中的★是放在**tuple[2][3]**。趕快來實驗看看範例程式吧。

**source code**
*tuple.c*
```cpp
#include <stdio.h>

int main(){

	int i,j;
	int tuple[4][5] = {{0}};

	tuple[2][3] = 1;

	for(i = 0; i < 4; i++){//>
		for(j = 0; j < 5; j++){//>
			printf("%d ", tuple[i][j]);
		}
		printf("\n");
	}

	return 0;
}
```
**執行結果:**
```
0 0 0 0 0 
0 0 0 0 0 
0 0 0 1 0 
0 0 0 0 0 
```
我們把剛剛有★的圖用程式畫出來了(1代表★)。雖然很囉唆，還是要再提醒第一個**[]**是縱方向，第二個**[]**是橫方向。初始化也可以一個一個指定，就像下面這樣:

```cpp
data_type 變數名[縱向元素數][橫向元素數] = 
{ {[0][0]初始值, [0][1]初始值, ...},
  {[1][0]初始值, [1][1]初始值, ...},
  {[2][0]初始值, [2][1]初始值, ...},
  ...
};
```
以這個例子來說，只要把剛剛tuple.c的
```cpp
	int tuple[4][5] = {{0}};

	tuple[2][3] = 1;
```
換成
```cpp
int tuple[4][5] = 
{ {0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0},
  {0, 0, 0, 1, 0},
  {0, 0, 0, 0, 0},
};
```
就是跟剛剛一樣的效果。

就像一維陣列可以省略元素數一樣，二維陣列也可以，但是能省略的只有縱方向，橫方向的元素數是一定要寫的。如下:
```cpp
int tuple[][5] = 
{ {0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0},
  {0, 0, 0, 1, 0},
  {0, 0, 0, 0, 0},
};
```
會不能兩邊都省略，是因為都省略的話compiler會不知道應該是4*5還是5*4。考慮到下面的例子也跟上面的結果是一樣的，就比較好理解了。
```cpp
int tuple[][5] = 
{ 0, 0, 0, 0, 0,0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
0, 0, 0, 0, 0};
```
可以再把剛剛的範例程式改造自動計算直到12*12的乘法表。

**source code**
*tuple_2.c*
```cpp
#include <stdio.h>

#define MAX_NUMBER 12

int create_tuple(int tuple[][MAX_NUMBER]){

	int i,j;

	if (tuple == NULL){
		return -1;
	}

	for(i = 0; i < MAX_NUMBER; i++){
		for(j = 0; j < MAX_NUMBER; j++){
			tuple[i][j] = (i + 1)*(j + 1);
		}
	}
	return 0;
}

int main(){

	int i,j;
	int tuple[MAX_NUMBER][MAX_NUMBER] = {{0}};

	create_tuple(tuple);


	for(i = 0; i < MAX_NUMBER; i++){
		for(j = 0; j < MAX_NUMBER; j++){
			printf("% 4d",tuple[i][j]);
		}
		printf("\n");
	}

	return 0;
}
```
**執行結果:**
```
   1   2   3   4   5   6   7   8   9  10  11  12
   2   4   6   8  10  12  14  16  18  20  22  24
   3   6   9  12  15  18  21  24  27  30  33  36
   4   8  12  16  20  24  28  32  36  40  44  48
   5  10  15  20  25  30  35  40  45  50  55  60
   6  12  18  24  30  36  42  48  54  60  66  72
   7  14  21  28  35  42  49  56  63  70  77  84
   8  16  24  32  40  48  56  64  72  80  88  96
   9  18  27  36  45  54  63  72  81  90  99 108
  10  20  30  40  50  60  70  80  90 100 110 120
  11  22  33  44  55  66  77  88  99 110 121 132
  12  24  36  48  60  72  84  96 108 120 132 144
```
怎樣呢? 12*12的乘法表漂亮的顯示出來了。這次兼具複習，也使用了**#define**，只要把12這數字給換掉，不管多大的表都可以做。還有，我們使用了生成表的函數。雖然我們的參數寫**int tuple[][MAX_NUMBER]**，但是其實也是跟指標給一樣的位址。那麼，為什麼用這種寫法呢? 

其實，compiler對於這個**int tuple[][MAX_NUMBER]**，會把它換成**int  *tuple**，也就是說，這個函數其實不是接受整個陣列，只是接受了tuple的開頭位址。

但是，想使用**tuple[i][j]**這種記法，就需要讓compiler知道「i每次前進1的時候，要前進多少位址才行」。**tuple[i][j]**在compiler中其實是表示成**\*(tuple + i\*MAX_NUMBER + j)**這種式子，為了計算這式子，就需要知道**MAX_NUMBER**(j部份的size)，並不是說為了使用[]來表示陣列就一定要用**int tuple[][MAX_NUMBER]**作為參數。

我們來試試用指標的表示實驗看看。把
```cpp
int create_tuple(int tuple[][MAX_NUMBER])
```
換成
```cpp
int create_tuple(int *tuple)
```
再把
```cpp
tuple[i][j] = (i + 1)*(j + 1);
```
換成
```cpp
*(tuple + i*MAX_NUMBER + j) = (i + 1)*(j + 1);
```
雖然會出現警告，但是結果是相同的。雖然在人類看起來是二維陣列，不過對compiler來說就是一直線的陣列，所以會有上面這些式子。順代一提，如果是一維陣列的話，在參數裡寫成*或[]都可以，如下圖:

```cpp
int function(char *string){
}
int function(char string[]){
}
```
不管哪一種，都只會傳指標而已。**char string[]**這種寫法，雖然因為是記成**[]**所以看起來像是把整個陣列複製給**function()**，但它其實只是指標。

要再次認識到，C語言無法傳遞陣列，只要是陣列一定是傳遞它的指標。

目前為止，二維陣列的第一個[]是縱，第二個[]是橫。不過不只二維，也可以宣告三維四維，這時候，哪個元素要怎樣處理就是看程式員本人了。比如說，三維陣列宣告方式如下:

```cpp
data_type 變數名[元素數][元素數][元素數]
```
可以把它想像成很多張二維陣列，也可以拿來表示三次元座標的x,y,z，但是四維五維陣列就很難想像了。

### 讓頭腦清醒一下

好不容易可以使用多維陣列了，來介紹有趣的例子吧。使用四維陣列的話，就可以很簡單的利用block來表現遊戲的圖形。具體來說，可以把圖形以二維陣列表示，迴轉等等處理以第三維表示，圖形的種類以第四維表示。來看看實例吧。

**source code**
*tuple_3.c*
```cpp
#include <stdio.h>

int main(){

	int tuple[][4][4][4] ={{{{0,0,0,0},{0,1,0,0},{1,1,1,0},{0,0,0,0}},
                            {{0,0,0,0},{0,1,0,0},{1,1,0,0},{0,1,0,0}},
                            {{0,0,0,0},{0,0,0,0},{1,1,1,0},{0,1,0,0}},
                            {{0,0,0,0},{0,1,0,0},{0,1,1,0},{0,1,0,0}}},
                           {{{0,0,0,0},{0,0,1,0},{0,1,1,0},{0,1,0,0}},
                            {{0,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,0,0}},
                            {{0,0,0,0},{0,0,1,0},{0,1,1,0},{0,1,0,0}},
                            {{0,0,0,0},{1,1,0,0},{0,1,1,0},{0,0,0,0}}},
                           {{{0,1,0,0},{0,1,0,0},{0,1,0,0},{0,1,0,0}},
                            {{0,0,0,0},{0,0,0,0},{1,1,1,1},{0,0,0,0}},
                            {{0,0,0,0},{0,1,0,0},{0,1,0,0},{0,1,0,0}},
                            {{0,0,0,0},{0,0,0,0},{1,1,1,1},{0,0,0,0}}},
                           {{{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}},
                            {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}},
                            {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}},
                            {{0,0,0,0},{0,1,1,0},{0,1,1,0},{0,0,0,0}}}
                         };
	
	int type;
	int rot;
	int i,j;

	for(type = 0; type < 5; type++){
		for(rot = 0; rot < 4; rot++){
			getchar();
			printf("\x1b[2J");
			printf("\x1b[0;0H");
			printf("\n");
			for(i = 0; i < 4; i++){
				for(j = 0; j < 4; j++){
					if(tuple[type][rot][i][j] == 1){
						printf("* ");
					}
					else{
						printf("  ");
					}
			   }
			printf("\n");
		    }
	    }
	}
	return 0;
}
```
這個程式是每按一次Enter，圖形就會轉一下，執行結果不好表示出來，就不寫了。四維陣列**tuple[][][][]**是圖形資料，可以想成1就是*號，每四組一起看
{0,0,0,0},
{0,1,0,0},
{1,1,1,0},
{0,0,0,0}
就是
```
(空白)
 *
***
(空白)
```
的意思。
陣列可以想成tuple[圖形種類][迴轉狀態][y][x]。

```cpp
			getchar();
			printf("\x1b[2J");
			printf("\x1b[0;0H");
			printf("\n");

```
每按一次Enter(就是程式中getchar())，圖形就會轉一下。下一行的印出\x1b[2J則是ascii的ANSI Escape sequences，可以拿來清螢幕。\x1b[0;0H也是Escape sequences，是把文字畫畫的位置弄回左上角。程式在Windows的環境中可能無法正常執行，不過可以感受一下氣氛。
```cpp
			for(i = 0; i < 4; i++){
				for(j = 0; j < 4; j++){
					if(tuple[type][rot][i][j] == 1){
						printf("* ");
					}
					else{
						printf("  ");
					}
			   }
			   printf("\n");
		    }

```
這個重複的處理則是遇到陣列的1的話就輸出*，0的話就輸出空白。

即使很囉唆，好好思考並實做會比較快理解。請一定要用自己的環境執行一下。