C語言準備了一種功能，可以讓一個變數代入另一個不同data type的變數，叫做「轉型(型態轉換)」。先詳細說明轉型吧，**int**一般在32bit電腦上是4bytes的大小，而**char**則是1byte的大小，如果像下面這樣寫會發生什麼事呢?

```cpp
int num_1 = 100;
char num_2 = num_1;
```
只要自己去實驗就知道，num_2是可以好好的儲存100的，這是因為**num_1**變成左邊的data type。但是，像下面這樣寫又會發生什麼呢?

```cpp
int num_1 = 1000;
char num_2 = num_1;
```
自己實驗的話，很可能會發現num_2變成-24這奇怪的值。

C語言的轉型，對於雙方都是需用正負號表示的整數型(有號整數)，是根據以下兩條規則處理:

1. 原來型態 &lt;= 後來型態 : 值不變
2. 原來型態 &gt;  後來型態 : 可以表示的話不變，不可以的話看compiler怎麼做

這次的例子符合第二條，所以變成奇怪的值。因為1000用2進位表示是1111101000，至少需要10bit才能表示，但是char只有1byte(8bit)，所以放不下。放不下的部份，也就是最左邊兩位被扔掉，變成11101000。由於最左邊是1，所以char會把它當負數處理，其結果就是-24(這裡不詳述是怎麼算出-24的)。

轉型還有其他規則，如果雙方都是無號正整數，規則如下:

1. 原來型態 &lt;= 後來型態 : 值不變
2. 原來型態 &gt;  後來型態 : 原來型態%(後來型態可以表示的最大值 + 1)

舉例:
```cpp
unsigned int num_1 = 1000;
unsigned char num_2 = num_1;
```
num_2的值會是1000 % (255 + 1) = 232。

如果原來型態是有號整數，後來型態是無號正整數，那麼規則如下:

原來型態 >= 0
1. 原來型態 &lt;= 後來型態 : 值不變
2. 原來型態 &gt;  後來型態 : 原來型態%(後來型態可以表示的最大值 + 1)

原來型態是負數
1. 原來型態 &lt;= 後來型態 : 原來型態%(後來型態可以表示的最大值 + 1)
2. 原來型態 &gt;  後來型態 : (後來型態可以表示的最大值 + 1) - (-原來型態%(後來型態可以表示的最大值 + 1))

舉例:
```cpp
char num_1 = -128;
unsigned int num_2 = num_1;
```
num_2 = -128 + (4294967295 + 1) = 4294967168

```cpp
int num_1 = -1000;
unsigned char num_2 = num_1;
```
num_2 = (255 + 1) - (-(-1000) % (255 + 1)) = 24


如果原來型態是無號正整數，後來型態是有號整數，那麼規則如下:
1. 原來型態 &lt;= 後來型態 : 值不變
2. 原來型態 &gt;  後來型態 : 可以表示的話不變，不可以的話看compiler怎麼做

如果原來型態是浮點數(double, float)，後來型態是有號整數，那麼規則如下:
1. 如果原來型態的整數部份可以讓有號整數表示的話，就只丟掉小數點，如果不能表示，則看compiler怎麼做

舉例:
```cpp
double num_1 = 3.14;
char num_2 = num_1;
```
num_2 = 3

如果原來型態是無號整數，後來型態是浮點數(double, float)，那麼規則如下:
1. 看compiler怎麼做，會變成近似值

舉例:
```cpp
unsigned long long num_1 = 1844674407370955161511u;
float num_2 = num_1;
```
num_2 = 18446744073709551616.00000 (Mac OS X 64bit)

```cpp
unsigned long long num_1 = 1844674407370955161511u;
long double num_2 = num_1;
```
num_2 = 18446744073709551615.00000 (Mac OS X 64bit)

都是浮點數
1. 原來型態 &lt;= 後來型態 : 值不變
2. 原來型態 &gt;  後來型態 : 可以表示的話不變，不可以的話看compiler怎麼做

以上都是討論在代入時如何轉型，但就算是式子的右邊也可能是不同性太的值再做運算。這時候，就是以右邊中最大的data type為準。比如說**double + int**的話，就是把int轉成double再做運算。

轉型這東西，與其把上面這些囉唆的規則通通記起來，不如注意「從大的data type代入到小的data type要注意」。如果一直跟自己的預想不同才來查這個表。