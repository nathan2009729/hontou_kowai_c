至今為止介紹的運算元，都是「式子 運算元 式子」這種型態，這種運算元又被稱為二元運算元。比如說

```cpp
a + b
a = b + c
a == b + c
```

C語言的話，還有**一元運算元**跟**三元運算元**這些特別的運算元可以利用。

### 一元運算元

**increament ++**
**decreament - -**
**正數 +**
**負數 -**
**反轉 ~**
**否定 !**

**++**在第一章有出場過，**++**還有**--**分別是把變數的值加1減1。使用方法很簡單，想把變數**n**的值increament跟decreament的寫法分別是
`n++`還有`n--`這樣而已，或者是`++n``--n`也行。不過這兩種寫法有些不同，先寫**++**/**- -**的話會先把變數的值加1/減1，後寫**++**/**- -**的話會先用原本的值進行記算後再加1/減1。來實驗看看範例程式吧。

**source code:**
*inc_1.c*
```cpp
#include <stdio.h>

int main(){
	int n;
	
	n = 0;
	printf("pre inc n = %d\n", ++n);
	printf("n = %d\n",n);

	n = 0;
	printf("post inc n = %d\n",n++);
	printf("n = %d\n",n);
	
	return 0;
}
```
**執行結果:**
```
pre inc n = 1
n = 1
post inc n = 0
n = 1
```
不管是**++n**跟**n++**，在第二次**printf()**時都是印出1，但是第一次**printf()**時，**++n**是1，**n++**是0。**++n**的情況，在第一次**printf()**時值已經改變了，**n++**的情況，在第一次**printf()**表示結果後才+1。像**++n**(**- -n**)這樣，把運算元寫在前面的情況我們叫做「preincreament」，**n++**(**n- -**)我們叫做「postincreament」。increament/decreament在學習制御構造的while跟for時會很常用，話是這麼說，但也不是這麼難吧。

**恐怖實驗:要注意寫++跟- -的地方**
雖然很阿莎力的說明了++跟- -，還是來實驗一下吧。`n = n + + +n + n`還有`n = n + n+ + + n`。大家預想了什麼結果呢?

**source code:**
*inc_2.c*

```cpp
#include <stdio.h>

int main(){
	int n;

	n = 1;
	printf("n = n + ++n + n = %d\n", n = n + ++n + n);
	printf("n = %d\n",n);

	n = 1;
	printf("n = n + n++ + n = %d\n", n = n + n++ + n);
	printf("n = %d\n",n);

	return (0);
}
```
compile時會出現警告
```
inc_2.c: In function ‘main’:
inc_2.c:7:37: warning: operation on ‘n’ may be undefined [-Wsequence-point]
  printf("n = n + ++n + n = %d\n", n = n + ++n + n);
                                     ^
inc_2.c:11:37: warning: operation on ‘n’ may be undefined [-Wsequence-point]
  printf("n = n + n++ + n = %d\n", n = n + n++ + n);
                                     ^
```
**執行結果:**
```
n = n + ++n + n = 6
n = 6
n = n + n++ + n = 5
n = 5
```
預想中了嗎?
在原本的書上，執行結果是這樣子的:
```
n = n + ++n + n = 6
n = 6
n = n + n++ + n = 3
n = 4
```
在解說前，先針對運算元的優先順位做說明吧。就像「式子與運算元」這節說的一樣，運算元有所謂的優先順位。之後會有優先順位一覽表，像**++**、**- -**還有**=**，比加法的**+**跟減法的**-**的優先度還要高。知道了這點再去看**n = n + ++n + n**這個式子，最先實行的是**++n**，這個時間點**n**的值變成2，再來才是執行加法，**2 + 2 + 2**這樣...其實這種考慮會落入陷阱。

C語言雖然決定了運算元的優先順位，但卻沒有嚴密的決定**式子的評價順位**，也就是說**++n**要什麼時候執行**++**是根據compiler的不同而有所不同。第一個式子的情況，原書的作者試過的機器中，只要不是太老舊的compiler都是出現6，但是也不可以太相信這個結果。

compile時出現的inc_2.c:7:37: warning: operation on ‘n’ may be undefined警告，它的意思是未定義處理的方式。在**n = n + n++ + n**這情況，原書是**1 + 1 + 1**加完後才執行**n++**，所以是3; 而筆者的compiler是一開始中間的**n**維持1，在執行加法之前**n**已經**++**變成2，所以是**2 + 1 + 2**，答案是5。總之，就是未定義。

### 變成一元運算元的二元運算元

**+**還有**-**這兩個二元運算元，依據場合可變成一元運算元，就是把數值指定成正數或負數。正數就算了，不用**-**號的話就無法表現負數，所以可以把**-**這個二元運算元變成一元運算元也是當然的吧。可以試試把form_1.c的程式碼變成`n = -1`執行看看。

**恐怖實驗:完全不做考慮的把運算元放在一起會怎樣?**

C語言把**+**還有**-**當作式子來處理，也可以把**-**當作負數處理。那麼，下面的式子正確嗎?

```cpp
answer = a - -b;
answer = a --- b;
```
先預想一下會出現什麼結果，來實驗看看範例程式吧。
**source code**
*dec.c*
```cpp
#include <stdio.h>

int main(){
	int a,b;
	int answer;

	a = 1;
	b = 1;
	answer = a- -b;
	printf("answer is %d\n", answer);

	a = 1;
	b = 1;
	answer = a --- b;
	printf("answer is %d\n", answer);

	return 0;
}
```
**執行結果:**
```
answer is 2
answer is 0
```
一開始的**answer = a- -b**應該很簡單吧。變數**a**，**b**都是1，所以式子變成**1- -1**，也就是**1 + 1**就是2。

問題是**answer = a - - - b**。一直都沒出現過**- - - **這種運算元，者裡的式子要解釋成**- -**跟**-**，變成**answer = (a - -) - b**。**a - -**在計算這式子的時候值為1，所以**1 - 1**答案是0。把**answer = a - - - b**改成`answer = a- --b`看看，這次的答案會變成1，因為**- -b**是0，**a**是1。

那麼，為何**a - - - b**會變成`a-- -b`呢? 因為C compiler對程式句子的解釋是由左到右的，--的優先位又比較高。使用同樣種類記號的運算元，意義會根據空白的場所而改變，在寫程式時要注意。輸入印刷在紙上的程式碼的時候，也要注意空白的位置。

不過，原本就不應該寫這麼囉唆的程式，所以幾乎不會看見的吧。

### 名為反轉的一元運算元

一元運算元之中有個有些奇怪的作用的運算元，是可以讓bit反轉的**~運算元**。寫程式的初心者可能沒什麼使用的機會，以防萬一還是記起來吧，`~數值`、`~變數名`這樣宣告。這樣宣告的話，就可以把這個數值或變數的bit全部反轉。舉個例子，考慮1431655765這個數字。它的2進位(bit的羅列)可以寫成01010101010101010101010101010101這樣的32bit。所謂的bit反轉就是0變1，1變0這樣，所以會變成10101010101010101010101010101010。把bit反轉後的2進位也當成32bit整數(**int**)來看的話，就是-1431655766。

**source code:**
*reverse.c*

```cpp
#include <stdio.h>

int main(){
	int n;

	n = 1431655765;
	printf("n is %d\n",n);
	printf("~n is %d\n",~n);

	return 0;
}
```
**執行結果:**
```
n is 1431655765
~n is -1431655766
```

### 否定的一元運算元(!)

最後的一元運算元，是進行否定的**!**。可以否定式子的結果，是什麼意思呢? 「條件式」的小節裡，說明了使用**<,>,<=,>=,==,!=**等等的條件式所出現的結果，不是1就是0，而這個運算元就是希望在條件不成立時進行分歧處理的符號。比如說我們希望在變數**a**跟變數**b**不相等時進行處理，我們就可以寫成

```cpp
if(!(a==b)){
	//分歧處理
}
```
當然也可以寫成
```cpp
if(a != b){
	//分歧處理
}
```

在寫複雜條件的情況下，這是非常有效的運算元。另外，為何**!(a==b)**要用括弧括起來，不能寫**!a == b**呢? 這是因為!運算元的優先度較高，寫成**!a == b**的話意思就會變成「**a**的否定要跟**b**相等」。之前說過，C語言的制御文除了0以外都會被當成「真」來解釋，所以為了條件式所用的!運算元，對普通的值還有式子使用的話，會有些特殊的結果。

**!0**的話，代表偽的否定，變成1。**!1**就是真的否定，變成1。而C語言對0以外都是真的，所以**!99**也會變成0。

優先度的事情，也在執行範例程式時確認一下吧。
**source code:**
*not.c*
```cpp
#include <stdio.h>

int main(){
	int a;
	int b;

	a = 1;
	b = 2;

	if(!(a == b)){
		printf("True\n");
	}

	if(!a == b){
		printf("False\n");
	}

	printf("!0 is %d\n", !0);
	printf("!1 is %d\n", !1);
	printf("!99 is %d\n", !99);

	return 0;
}

```

**執行結果:**
```
True
!0 is 1
!1 is 0
!99 is 0
```
要注意compile時會出現警告
```
not.c: In function ‘main’:
not.c:14:8: warning: logical not is only applied to the left hand side of comparison [-Wlogical-not-parentheses]
  if(!a == b){
        ^
```
**!99**這種，大概不會用到吧，作為知識記起來也沒什麼損失。也可以把範例程式改造一下，看看**!!99**會是怎樣的值。這樣的話，會有更深的認識吧。

!運算元，本來的意思是想把跟條件式相反的情況當作條件使用。但是在程式員中，有人會把「變數為0的時候」當作條件(變數為0時為真)，利用!運算元。這是怎麼一回事呢?

就像剛剛的範例程式實驗的一樣，**!0**的結果會是1。1在if等等的制御文中是「真」的意思，所以!運算元可以利用在想在0的時候做分歧處理的情況。就像下面寫法這樣。
```cpp
a = 0;

if(!a){
	printf("a is 0\n");
}
```
原書作者認為這樣不好懂，乾脆寫成**a==0**就可以了，不過寫**!a**很多，所以記起來吧。

### 只有一個的三元運算元，?:

三元運算元與其他的運算元不同，只有一個。記號是**?**跟**:**組合的，比較奇怪的東西。而這記號可以寫出條件分歧。寫法如下:

`條件 ? 條件為真時的式子 : 條件為偽時的式子;`

使用這個的話，不得不用if的條件分歧可以只用1行式子寫完。趕快來執行看看範例程式吧。

**source code:**
*cond.c*
```cpp
#include <stdio.h>

int main(){
	int a;

	a = -1;

	printf("absolute value is %d\n", a > 0 ? a : -a);

	return 0;
}
```
**執行結果:**
```
absolute value is 1
```
這個範例程式是拿來求變數**a**的絕對值的。如果用if的話，就會像下面這樣需要用到五行，三元運算元不但只要寫一行，而且問號後面不是句子而是式子，會比較短，所以就寫在**printf()**裡了。

```cpp
if (a > 0){
	printf("absolute value is %d\n", a);
} else{
	printf("absolute value is %d\n", -a);
}
```
因為**printf()**函數的呼叫本身也是式子，所以也可以這樣寫。
**注意，因為冗長所以不建議**
```cpp
a > 0 ? printf("absolute value is %d\n", a) : printf("absolute value is %d\n", -a);
```

雖然是很便利的運算元，但是用太多的話會變得不知道在寫什麼，**重點是使用的時機**。舉例來說，下圖的程式，是把變數**a**的絕對值減掉變數**b**的絕對值，結果是偶數的話印出even，是奇數的話印出odd，但是太複雜了變得看不太懂。

```cpp
((a > 0 ？ a : -a) - (b > 0 ？ b : -b)) % 2 ? printf("odd\n") : printf("even\n");
```